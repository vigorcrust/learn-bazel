# learn-bazel

I try to document my way of figuring out bazel, which might become a tutorial...


## versions

I already worked a few hours with bazel writing this paragraph and looking 
through various documentations I realize that the documentation I found on the 
internet are using sometimes very old versions of bazel. To clear it up for
myself and potential readers I am using **bazel 8.1.1**, so the latest version
as of **March, 2025**.


## install

There are a few tutorials how to install bazel or the bazel version mannager
"bazelisk" and I do it differently depending on the environment I am 
currently working on or use for testing.

I basicaly followed the instructions of 
[Official Bazel Docs](https://bazel.build/install) and 
[Official Bazelisk Docs](https://github.com/bazelbuild/bazelisk?tab=readme-ov-file#installation).

So on MACOSX I useed `brew install bazelisk`, on a fresh Debian I used 
`apt-get install nodejs npm` and installed with `npm install -g @bazel/bazelisk`
on other Linux distros I used the other package manager.

As additional tool, but more for learning & remembering stuff I use 
[just](https://github.com/casey/just?tab=readme-ov-file#packages).


## structure of the repo

Because I want to try out a few things, the root of the repo is not a bazel
project, but more an starting point for multiple bazel projects and the current
documentation.

```
.
├── README.md
├── justfile
└── projects
    ├── 001_bootstrap
    │   └── README.md
    └── ...
```


## projects


### 001_bootstrap

My first project, just to see what the building blocks are.
`WORKSPACE` is an "old" concept of defining a project, so you should define 
it with `MODULE.bazel`. You can use as extension `bzl`, but I don't mind writing
more characters and maybe I change it later.

- name of the module must follow a naming convention: `^[a-z][a-z0-9._-]*[a-z0-9]$`

After running `just learn_001_bootstrap_build`, it warns that no targets are
found, but completes successfully - obviously, because I didn't define anything.

It created a few symlinks:
```
  bazel-001_bootstrap/ -> /.../execroot/_main/
  bazel-bin/ -> /.../execroot/_main/bazel-out/darwin_arm64-fastbuild/bin/
  bazel-out/ -> /.../execroot/_main/bazel-out/
  bazel-testlogs/ -> /.../execroot/_main/bazel-out/darwin_arm64-fastbuild/testlogs/
```
You also see that I am currently working on an MAC Mx system - not my decision,
privatly I use arch btw.

I added a .gitignore file generated by [toptal](https://www.toptal.com/developers/gitignore/api/bazel)
to ignore the symlinks.

So, now I am setup and I am thing what could be the easiesst thing I can do...
I could just write a file?!

I googled `bazel write file` and I found a module called bazel_skylib which 
provides some helper functions. One of those is `write_file`.

To add the dependency to this project I need to
1. tell bazel the dependency
2. load the rules I need for "building"
3. tell bazel what exactly I want.

I found the [Official Registry of bazel](https://registry.bazel.build/all-modules)
where I searched for the module and it told me to add the line:
```
bazel_dep(name = "bazel_skylib", version = "1.7.1")
```
to the `MODULE.bazel` - so step 1 was done.

Now I needed to load the rules, so I went to the main github page of 
[skylib](https://github.com/bazelbuild/bazel-skylib) and found the documentation
of [write_file](https://github.com/bazelbuild/bazel-skylib/blob/main/docs/write_file_doc.md).
I went through all the arguments and ended up with:
```
write_file(
  name = "write_some_text", 
  out = "hello_world.txt", 
  content = ["Hello World"],
)
```

I am ready now, and execute `bazel build :all`, to build all targets.
And it generated the file:
```
INFO: Analyzed target //:write_some_text (0 packages loaded, 0 targets configured).
INFO: Found 1 target...
Target //:write_some_text up-to-date:
  bazel-bin/hello_world.txt
INFO: Elapsed time: 0.211s, Critical Path: 0.01s
INFO: 1 process: 1 internal.
INFO: Build completed successfully, 1 total action
```

Amazing, it works.

Off to the next project...


### 002_my_rule

Maybe to understand better how rules work it's best to write my own,
maybe similar what I did before with an external dependency?

Because I don't need any dependencies I could leave the `MODULE.bazel` blank,
but I just bootstrap it and make the `module(...)` definition.

Probably I need a folder for the rules and call it `tools` and put my rule in there.

In the `BUILD.bazel` I load my local rule and invoke the function to be called.

I found a little tutorial on youtube how to create a rule and I used that as
a template to see how implement something like that.

Basically you need to define:
```
<name of the rule I want to use in BUILD> = rule(#
    implementation = <python/starlark function to be called>,
    attrs = [    // List of all attributes used for the function
        "parameter_a" : <type of parameter>,
        ...
    ]
)
```

Then you need to create the implementation function, in my case:
```
def write_new_file_impl(ctx):
  content = ctx.attr.content
  out = ctx.actions.declare_file(ctx.attr.out)

  ctx.actions.write(
    output = out,
    content = "\n".join(content),
  )

  return [DefaultInfo(files = depset([out]))]
```

to note `ctx` is used to for the input parameters, basic actions and for defining
the output. The last line with `return [DefaultInfo...` is used to tell bazel 
that there is an outpout defined with a `depset` - as I understand it a 
dependecy set other modules/rules can depend on as the output of this rule.


### 003_dependencies

I know that using dependencies is a tiny bit different, but it is a good and 
easy example to see how this works.

I took the 001_... project - writing a file with skylib - used that as a package
inside this project. Then I needed to do something with it, so I decided to plain
and simple have a shell script to `cat` the file. For this I was searching for a bit,
but found in the bazel registry rules_shell with the sh_binary rule. So I copied the
001 project, created 2 folders subA and subB and copied the BUILD.bazel file to subA/

Now I added the dependecy to MODULE.bazel and created a new BUILD.bazel inside subB/
folder. In the meantime I tested subA to see how the bazel path looked like.

I also created a shell script in subB to be executed, but just did some debugging
info at first like `env`, `pwd`, `echo $0`, `tree`. When I tested it I got an error
that it is not an executable so I `chmod +x` the script. After that the script worked
fine.

The final step I had to do was to `cat` the file from subA/ folder - this took a few
minutes to google it, but finally I got it in a way that works for now.

One important step I nearly forgot to mention is that I needed to change subA's
visibility. So not to fuss around I changed the visibility to 
[public](https://bazel.build/concepts/visibility?hl=en#visibility-specifications).

So this was a nice little learning session in between my actual work to see how
dependencies work in a way, how to reference other BUILD targets and get a little
understanding about visibility.


### 004_java_basic

In my job I work with a few languages, but quite a few projects are JVM based.
Although we currently develop quite a lot in Kotlin, I would start with plain
Java and if that is working I would maybe continue with Kotlin.

I would like to create something similar as 003 and create a library and 
another class with a main function. Maybe I also want to add a unit test
to see how this works as well.

First, I start with a main and print something to console. Second, create a 
simple lib with a static add(int, int) function and try to call it from the main.

After tinkering a few minutes with it, it worked. I can build the lib and app
independently and the app is refrencing the lib.

I added (also to the other projects) the `.bazelversion`, so when I run bazelisk
it actually uses the defined version. I also added nearly empty `WORKSPACE` file
to all projects as it seems to be common practice although not really needed.

Actually I wanted to also use external dependencies, but I realized that it is a
bit more work, so I postpone it to the next project.


